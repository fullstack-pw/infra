name: Ansible Provisioning

on:
  push:

jobs:
  detect-ansible-command:
    if: >
      (github.event_name != 'pull_request' && contains(github.event.head_commit.message, '[ansible'))
    runs-on: self-hosted
    outputs:
      playbook: ${{ steps.get-playbook.outputs.playbook }}
      should_run: ${{ steps.get-playbook.outputs.should_run }}
    steps:
      - name: Extract Ansible Playbook from Commit Message
        id: get-playbook
        run: |
          # Handle different event types
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
            COMMIT_MSG="${{ github.event.pull_request.head.label }} ${{ github.event.pull_request.body }}"
            COMBINED="$PR_TITLE $COMMIT_MSG"
          else
            COMBINED="${{ github.event.head_commit.message }}"
          fi

          # Look for [ansible playbook-name] pattern
          if [[ $COMBINED =~ \[ansible[[:space:]]+([^\]]+)\] ]]; then
            PLAYBOOK="${BASH_REMATCH[1]}"
            # Trim whitespace
            PLAYBOOK=$(echo $PLAYBOOK | xargs)
            echo "Found playbook: $PLAYBOOK"
            echo "playbook=$PLAYBOOK" >> $GITHUB_OUTPUT
            echo "should_run=true" >> $GITHUB_OUTPUT
          else
            echo "No ansible command found in commit message"
            echo "should_run=false" >> $GITHUB_OUTPUT
          fi
  run-ansible:
    needs: detect-ansible-command
    if: needs.detect-ansible-command.outputs.should_run == 'true'
    runs-on: self-hosted
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Install Ansible
        run: |
          python3 -m pip install --upgrade pip
          pip install ansible

      - name: Determine Playbook Path
        id: playbook-path
        run: |
          PLAYBOOK="${{ needs.detect-ansible-command.outputs.playbook }}"
          echo "Processing playbook: $PLAYBOOK"

          if [[ $PLAYBOOK =~ ^talos-(.+)$ ]]; then
            # Talos cluster - use talos-bootstrap.yml
            echo "Detected Talos cluster: ${BASH_REMATCH[1]}"
            echo "PLAYBOOK_PATH=proxmox/playbooks/talos-bootstrap.yml" >> $GITHUB_ENV
            echo "CLUSTER_NAME=${BASH_REMATCH[1]}" >> $GITHUB_ENV
            echo "PLAYBOOK_TYPE=talos" >> $GITHUB_ENV
          elif [[ $PLAYBOOK =~ ^k8s-(.+)$ ]]; then
            # K3s cluster - use k8s.yml
            echo "Detected K3s cluster: ${BASH_REMATCH[1]}"
            echo "PLAYBOOK_PATH=proxmox/playbooks/k8s.yml" >> $GITHUB_ENV
            echo "CLUSTER_NAME=${BASH_REMATCH[1]}" >> $GITHUB_ENV
            echo "PLAYBOOK_TYPE=k3s" >> $GITHUB_ENV
          else
            # Direct playbook execution
            echo "Detected direct playbook: $PLAYBOOK"
            if [ -f "proxmox/playbooks/${PLAYBOOK}.yml" ]; then
              echo "Found direct playbook file: proxmox/playbooks/${PLAYBOOK}.yml"
              echo "PLAYBOOK_PATH=proxmox/playbooks/${PLAYBOOK}.yml" >> $GITHUB_ENV
              echo "PLAYBOOK_TYPE=direct" >> $GITHUB_ENV
            else
              echo "Playbook file not found for: ${PLAYBOOK}"
              echo "Searched for: proxmox/playbooks/${PLAYBOOK}.yml"
              exit 1
            fi
          fi

          echo "Final PLAYBOOK_PATH: $(echo $PLAYBOOK_PATH)"

      - name: Prepare Environment
        run: |
          mkdir -p ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_rsa
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_ed25519

          # Check if we have new hosts to limit execution to
          if [ -f "proxmox/new_hosts.txt" ] && [ -s "proxmox/new_hosts.txt" ]; then
            echo "Found new hosts, adding them to known_hosts:"
            
            # Loop through new hosts file
            while IFS=, read -r IP ENV; do
              if [ -n "$IP" ] && [[ $IP =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+ ]]; then
                echo "Adding new host $IP to known_hosts..."
                ssh-keyscan -H $IP >> ~/.ssh/known_hosts 2>/dev/null || echo "Warning: Could not scan $IP"
              fi
            done < proxmox/new_hosts.txt
          else
            echo "No new hosts found, not scanning any hosts"
          fi
        if: env.PLAYBOOK_PATH != ''

      - name: Execute Playbook
        run: |
          export PATH=$PATH:/home/runner/.local/bin
          export ANSIBLE_HOST_KEY_CHECKING=False

          PLAYBOOK_TYPE="${{ env.PLAYBOOK_TYPE }}"
          PLAYBOOK_PATH="${{ env.PLAYBOOK_PATH }}"

          echo "Executing $PLAYBOOK_TYPE playbook: $PLAYBOOK_PATH"

          if [[ "$PLAYBOOK_TYPE" == "talos" ]]; then
            # Talos cluster bootstrap - run once for entire cluster
            CLUSTER_NAME="${{ env.CLUSTER_NAME }}"
            echo "Bootstrapping Talos cluster: $CLUSTER_NAME"
            
            # First configure HAProxy if it exists
            if ansible-inventory -i proxmox/k8s.ini --list | jq -r '.all.children' | grep -q "haproxy"; then
              HAPROXY_HOST="talos-${CLUSTER_NAME}-haproxy"
              if ansible-inventory -i proxmox/k8s.ini --list | jq -r '._meta.hostvars | keys[]' | grep -q "$HAPROXY_HOST"; then
                echo "Configuring HAProxy for cluster: $CLUSTER_NAME"
                ansible-playbook proxmox/playbooks/haproxy-config.yml -i proxmox/k8s.ini -e "target_hosts=$HAPROXY_HOST"
              fi
            fi
            
            # Bootstrap entire Talos cluster
            ansible-playbook $PLAYBOOK_PATH -i proxmox/k8s.ini -e "target_hosts=$CLUSTER_NAME"
            
          elif [[ "$PLAYBOOK_TYPE" == "k3s" ]]; then
            # K3s cluster setup - run once for cluster
            CLUSTER_NAME="${{ env.CLUSTER_NAME }}"
            echo "Setting up K3s cluster: $CLUSTER_NAME"
            ansible-playbook $PLAYBOOK_PATH -i proxmox/k8s.ini -e "target_hosts=$CLUSTER_NAME" -e "vault_token=${VAULT_TOKEN}" -e "vault_addr=https://vault.fullstack.pw"
            
          else
            # Direct playbook - check if we should limit to new hosts
            if [ -f "proxmox/new_hosts.txt" ] && [ -s "proxmox/new_hosts.txt" ]; then
              echo "Found new hosts, running playbook only on them:"
              cat proxmox/new_hosts.txt
              
              # Run the playbook for each new host individually
              while IFS=, read -r IP ENV; do
                if [ -n "$IP" ] && [ -n "$ENV" ]; then
                  echo "Running playbook for new host: $IP ($ENV)"
                  # Create temporary inventory for this host
                  TEMP_INVENTORY=$(mktemp)
                  echo "[all]" > $TEMP_INVENTORY
                  echo "$IP ansible_user=suporte" >> $TEMP_INVENTORY
                  
                  ansible-playbook -i "$TEMP_INVENTORY" $PLAYBOOK_PATH \
                    -e "ansible_user=suporte" \
                    -e "target_hosts=all" \
                    -e "vault_token=${VAULT_TOKEN}" \
                    -e "vault_addr=https://vault.fullstack.pw"
                  
                  rm $TEMP_INVENTORY
                fi
              done < proxmox/new_hosts.txt
            else
              # No new hosts, run normally
              echo "No new hosts found, running playbook normally"
              ansible-playbook $PLAYBOOK_PATH -i proxmox/k8s.ini
            fi
          fi

      - name: Notify Completion
        run: |
          echo "✅ Ansible playbook execution completed: ${{ needs.detect-ansible-command.outputs.playbook }}"
        if: success() && env.PLAYBOOK_PATH != ''

      - name: Notify Failure
        if: failure() && env.PLAYBOOK_PATH != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## Ansible Provisioning Failed
              
              ❌ Failed to run ansible playbook: \`${{ needs.detect-ansible-command.outputs.playbook }}\`
              
              Please check the workflow logs for more details.
              `
            })
