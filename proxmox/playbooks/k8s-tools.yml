---
- name: Install Single-Node K3s for Tools Cluster
  hosts: "{{ target_hosts | default('tools') }}"
  become: true
  gather_facts: yes
  vars:
    vault_addr: "https://vault.fullstack.pw"
    cluster_name: "{{ inventory_hostname | regex_replace('\\..*$', '') }}"

  tasks:
    - name: Install dependencies (if needed)
      apt:
        name:
          - curl
          - apt-transport-https
          - ca-certificates
        state: present
        update_cache: yes

    - name: Install K3s
      shell: |
        curl -sfL https://get.k3s.io | sh -s -
      args:
        executable: /bin/bash

    - name: Wait for K3s service
      service:
        name: k3s
        state: started
        enabled: true

    - name: Display node token
      shell: cat /var/lib/rancher/k3s/server/node-token
      register: node_token
      changed_when: false

    - debug:
        msg: "Node token for {{ inventory_hostname }}: {{ node_token.stdout }}"

    - name: Fetch kubeconfig
      shell: cat /etc/rancher/k3s/k3s.yaml
      register: kubeconfig_content
      changed_when: false

    - name: Create local temp directory
      delegate_to: localhost
      become: false
      file:
        path: ./tmp
        state: directory
      run_once: true

    - name: Save new cluster kubeconfig to local file
      delegate_to: localhost
      become: false
      copy:
        content: "{{ kubeconfig_content.stdout | replace('127.0.0.1', inventory_hostname) | replace('default', cluster_name) }}"
        dest: "./tmp/{{ cluster_name }}-kubeconfig"
      run_once: true

    - name: Install yq (YAML processing tool)
      delegate_to: localhost
      become: false
      shell: |
        if ! command -v yq &> /dev/null; then
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq
        fi
      run_once: true
      args:
        executable: /bin/bash

    - name: Install Vault CLI
      delegate_to: localhost
      become: false
      shell: |
        if ! command -v vault &> /dev/null; then
          curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -
          sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"
          sudo apt-get update
          sudo apt-get install -y vault
        fi
      run_once: true
      args:
        executable: /bin/bash

    - name: Retrieve existing kubeconfig from Vault
      delegate_to: localhost
      become: false
      environment:
        VAULT_ADDR: "{{ vault_addr }}"
        VAULT_TOKEN: "{{ vault_token }}"
      shell: |
        # Create an empty kubeconfig if it doesn't exist in Vault
        vault kv get -format=json kv/gitlab_runner | jq -r '.data.data.KUBECONFIG // empty' > ./tmp/existing-kubeconfig
        if [ ! -s ./tmp/existing-kubeconfig ]; then
          echo "No existing kubeconfig found. Creating a new one."
          cat ./tmp/{{ cluster_name }}-kubeconfig > ./tmp/existing-kubeconfig
        fi
      run_once: true
      args:
        executable: /bin/bash
      when: vault_token is defined

    - name: Merge kubeconfig files
      delegate_to: localhost
      become: false
      shell: |
        # Process the new kubeconfig to use the cluster name in context
        yq eval '.clusters[0].name = "{{ cluster_name }}"' -i ./tmp/{{ cluster_name }}-kubeconfig
        yq eval '.contexts[0].name = "{{ cluster_name }}"' -i ./tmp/{{ cluster_name }}-kubeconfig
        yq eval '.contexts[0].context.cluster = "{{ cluster_name }}"' -i ./tmp/{{ cluster_name }}-kubeconfig
        yq eval '.contexts[0].context.user = "{{ cluster_name }}"' -i ./tmp/{{ cluster_name }}-kubeconfig
        yq eval '.users[0].name = "{{ cluster_name }}"' -i ./tmp/{{ cluster_name }}-kubeconfig

        # Only merge if there's an existing kubeconfig with content
        if [ -s ./tmp/existing-kubeconfig ]; then
          # Extract components from the new kubeconfig
          NEW_CLUSTER=$(yq eval '.clusters[0]' ./tmp/{{ cluster_name }}-kubeconfig)
          NEW_CONTEXT=$(yq eval '.contexts[0]' ./tmp/{{ cluster_name }}-kubeconfig)
          NEW_USER=$(yq eval '.users[0]' ./tmp/{{ cluster_name }}-kubeconfig)
          
          # Add new components to existing kubeconfig
          yq eval '.clusters += ['"$NEW_CLUSTER"']' -i ./tmp/existing-kubeconfig
          yq eval '.contexts += ['"$NEW_CONTEXT"']' -i ./tmp/existing-kubeconfig
          yq eval '.users += ['"$NEW_USER"']' -i ./tmp/existing-kubeconfig
        fi

        # Display the merged kubeconfig for debugging
        echo "Merged kubeconfig:"
        cat ./tmp/existing-kubeconfig
      run_once: true
      args:
        executable: /bin/bash

    - name: Store updated kubeconfig in Vault
      delegate_to: localhost
      become: false
      environment:
        VAULT_ADDR: "{{ vault_addr }}"
        VAULT_TOKEN: "{{ vault_token }}"
      shell: |
        # Update the gitlab_runner secret
        vault kv put kv/gitlab_runner KUBECONFIG="$(cat ./tmp/existing-kubeconfig)" GITLAB_TOKEN="$(vault kv get -format=json kv/gitlab_runner | jq -r '.data.data.GITLAB_TOKEN // empty')"

        # Update the cluster-secrets-es secret
        vault kv put kv/cluster-secret-store/secrets/KUBECONFIG KUBECONFIG="$(cat ./tmp/existing-kubeconfig)"

        echo "Kubeconfig updated in Vault successfully"
      run_once: true
      args:
        executable: /bin/bash
      when: vault_token is defined

    - name: Clean up temporary files
      delegate_to: localhost
      become: false
      file:
        path: ./tmp
        state: absent
      run_once: true
