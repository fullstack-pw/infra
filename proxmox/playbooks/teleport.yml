---
- name: Install and Configure Teleport Community Edition
  hosts: teleport
  become: true
  vars:
    teleport_version: "17.7.1"
    teleport_edition: "oss"  # Community Edition
    teleport_domain: "teleport.fullstack.pw"
    teleport_cluster_name: "fullstack-pw"
    github_org: "fullstack-pw"
    minio_endpoint: "s3.fullstack.pw"
    minio_bucket: "teleport-recordings"
    
  tasks:
    - name: Update system packages
      apt:
        update_cache: true
        upgrade: dist
        autoremove: true

    - name: Install required packages
      apt:
        name:
          - curl
          - ca-certificates
          - gnupg
          - software-properties-common
          - apt-transport-https
          - acl
        state: present

    - name: Check if Teleport is already installed
      stat:
        path: /usr/local/bin/teleport
      register: teleport_installed

    - name: Download Teleport installation script
      get_url:
        url: https://cdn.teleport.dev/install.sh
        dest: /tmp/install_teleport.sh
        mode: '0755'
      when: not teleport_installed.stat.exists
      become: true

    - name: Run Teleport installation script with timeout
      shell: |
        export TELEPORT_EDITION="{{ teleport_edition }}"
        export TELEPORT_VERSION="{{ teleport_version }}"
        /tmp/install_teleport.sh ${TELEPORT_VERSION?} ${TELEPORT_EDITION?}
      args:
        executable: /bin/bash
      async: 300  # Maximum runtime in seconds (5 minutes)
      poll: 0  # Fire-and-forget (we'll check status later)
      register: install_result
      when: not teleport_installed.stat.exists
      become: true

    - name: Wait for installation to complete
      async_status:
        jid: "{{ install_result.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      retries: 30  # 30 * 10 = 300 seconds
      delay: 10  # Check every 10 seconds
      when: not teleport_installed.stat.exists

    - name: Verify installation success
      fail:
        msg: "Teleport installation timed out after 5 minutes"
      when: 
        - not teleport_installed.stat.exists
        - not job_result.finished

    - name: Cleanup installation script
      file:
        path: /tmp/install_teleport.sh
        state: absent
      become: true

    - name: Add /usr/local/bin to secure_path for sudo
      lineinfile:
        path: /etc/sudoers.d/secure_path
        line: "Defaults secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin"
        create: true
        mode: '0440'

    - name: Create Teleport directories
      file:
        path: "{{ item }}"
        state: directory
        owner: root
        group: root
        mode: '0755'
      loop:
        - /etc/teleport
        - /var/lib/teleport

    - name: Install certbot and dependencies
      apt:
        name: 
          - certbot
          - python3-certbot-dns-cloudflare
          - python3-pip
          - pipx
        state: present

    - name: Create Cloudflare credentials file
      copy:
        content: |
          # Cloudflare API token (recommended)
          dns_cloudflare_api_token = {{ cloudflare_api_token }}
        dest: /etc/letsencrypt/cloudflare.ini
        mode: '0600'
        owner: root
        group: root
      when: cloudflare_api_token is defined

    - name: Generate Let's Encrypt certificate
      command: >
        certbot certonly
        --dns-cloudflare
        --dns-cloudflare-credentials /etc/letsencrypt/cloudflare.ini
        --email {{ cloudflare_email }}
        --agree-tos
        --non-interactive
        --domains {{ teleport_domain }},*.{{ teleport_domain }}
      args:
        creates: "/etc/letsencrypt/live/{{ teleport_domain }}/fullchain.pem"

    - name: Copy certificates to Teleport directory
      copy:
        src: "/etc/letsencrypt/live/{{ teleport_domain }}/{{ item.src }}"
        dest: "/var/lib/teleport/{{ item.dest }}"
        owner: root
        group: root
        mode: '0600'
        remote_src: true
      loop:
        - { src: "fullchain.pem", dest: "fullchain.pem" }
        - { src: "privkey.pem", dest: "privkey.pem" }

    - name: Generate initial Teleport configuration using teleport configure
      shell: |
        teleport configure \
          --cluster-name="{{ teleport_cluster_name }}" \
          --public-addr="{{ teleport_domain }}:443" \
          --cert-file="/var/lib/teleport/fullchain.pem" \
          --key-file="/var/lib/teleport/privkey.pem" \
          --data-dir="/var/lib/teleport" \
          --output=file:///etc/teleport.yaml
      args:
        creates: /etc/teleport.yaml

    - name: Update Teleport configuration with custom settings
      template:
        src: teleport.yaml.j2
        dest: /etc/teleport.yaml
        owner: root
        group: root
        mode: '0600'
        backup: true
      notify: restart teleport

    - name: Set up certificate renewal cron job
      cron:
        name: "Renew Let's Encrypt certificates"
        minute: "0"
        hour: "2"
        job: "/usr/bin/certbot renew --quiet && /bin/systemctl reload teleport"
        user: root

    - name: Enable and start Teleport service
      systemd:
        name: teleport
        enabled: true
        state: started
        daemon_reload: true
        
    - name: Wait for Teleport to be ready
      wait_for:
        port: 3080
        host: localhost
        delay: 10
        timeout: 60

    - name: Create database access role
      shell: |
        /usr/local/bin/tctl create <<'EOF'
        kind: role
        version: v7
        metadata:
          name: db-access
        spec:
          allow:
            db_labels:
              "*": "*"
            db_names:
            - postgres
            - "*"
            db_users:
            - admin
            - "*"
        EOF
      register: create_role_result
      failed_when: 
        - create_role_result.rc != 0
        - "'already exists' not in create_role_result.stderr"
      changed_when: "'already exists' not in create_role_result.stderr"

    - name: Update admin user with database access role
      shell: |
        # Get current user config
        /usr/local/bin/tctl get user/admin > /tmp/admin-user.yaml
        
        # Check if db-access role is already present
        if ! grep -q "db-access" /tmp/admin-user.yaml; then
          # Add db-access to roles list
          sed -i '/^  roles:/a\  - db-access' /tmp/admin-user.yaml
          
          # Apply updated config
          /usr/local/bin/tctl create -f /tmp/admin-user.yaml --force
          echo "Added db-access role to admin user"
        else
          echo "db-access role already present for admin user"
        fi
        
        # Cleanup
        rm -f /tmp/admin-user.yaml
      register: update_user_result
      changed_when: "'Added db-access role' in update_user_result.stdout"

    - name: Display connection information
      debug:
        msg: |
          ‚úÖ Teleport has been installed and configured successfully!
          
          üåê Access URL: https://{{ teleport_domain }}
          üîß Config file: /etc/teleport.yaml
          üìã Service: systemctl status teleport
          
          üìù Next steps:
          1. Create the first user:
             sudo tctl users add admin --roles=access,auditor,editor --logins=root,ubuntu
          
          2. Get the join token for Kubernetes agents:
             sudo tctl tokens add --type=kube --ttl=8760h
          
          3. Check service status:
             sudo systemctl status teleport
          
          4. View logs:
             sudo journalctl -u teleport -f

  handlers:
    - name: reload systemd
      systemd:
        daemon_reload: true

    - name: restart teleport
      systemd:
        name: teleport
        state: restarted